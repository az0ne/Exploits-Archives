Greetings.

There is a way to disable tcpdump running on a remote host.  By sending a
carefully crafted UDP packet on the network which tcpdump monitors, it is
possible, under certain circonstances, to make tcpdump fall into an infinite
loop.

This undesired behaviour has serious consequences for any intrusion
detection system or any other network monitoring program which relies on
tcpdump's output.


tcpdump interprets UDP packet from or to port 53 as DNS traffic.
Consequently, tcpdump attempts to retreive information (such as domain names
in this case) in DNS queries and replies and display it.  However, domain
names in DNS packets use a compression scheme to avoid multiple occurences
of a domain name in the same packet.  This scheme uses jumps to a particular
offset in the packet.

If this jump offset is set to its own location and if a program trying to
decompress the domain name does not have any type of counter or strategy to
avoid infinite loops, then the program will jump to the same offset in the
packet over and over again.

Here is an example of it:

[bretonh@pgci.ca] # /usr/local/sbin/tcpdump
tcpdump: listening on hme0
--- usual traffic
--- dnsloop.c is run somewhere with paranoia.pgci.ca as target
18:44:50.985686 some-host-on-the-internet.port > paranoia.pgci.ca.domain: 61094 A?

tcpdump is now disabled, and any program requiring its output to detect
DoS attacks or to monitor the network in any other fashion is now out of
order.

The dnsloop.c program can be obtained at
ftp://ftp.pgci.ca/pub/tcpdump_tools/dnsloop.c

It must be mentionned that tcpdump running in quiet mode will not try
to interpret DNS traffic and is therefore unaffected by this problem.  Also,
if tcpdump writes the output directly to a file, the problem will not appear
while collecting packets, but while displaying them.

As an example of this, the SHADOW IDS is composed of a sensor part which only
collects packets and writes them directly in a file.  This bug will not
affect the sensor.  However, the analyzer module runs these packets through
tcpdump afterwards and just might experience problems if it encounters this
type of DNS loop attack (although correct me if I'm wrong about the inner
workings of SHADOW).


This problem can be fixed by adding a counter in the loop of the ns_print()
function in print-domain.c to stop printing a domain name once X loops have
been done.  Here is a new ns_print() function that fixes this problem:

static const u_char *
ns_nprint(register const u_char *cp, register const u_char *bp)
{
        register u_int i,j;
        register const u_char *rp;
        register int compress;

        i = *cp++;
        j = 0;
        rp = cp + i;
        if ((i & INDIR_MASK) == INDIR_MASK) {
                rp = cp + 1;
                compress = 1;
        } else
                compress = 0;
        if (i != 0)
                while ((i && cp < snapend) && (j<256)) {
                        j++;
                        if ((i & INDIR_MASK) == INDIR_MASK) {
                                cp = bp + (((i << 8) | *cp) & 0x3fff);
                                i = *cp++;
                                continue;
                        }
                        if (fn_printn(cp, i, snapend))
                                break;
                        cp += i;
                        putchar('.');
                        i = *cp++;
                        if (!compress)
                                rp += i + 1;
                }
        else
                putchar('.');
        return (rp);
}

Only the "j" variable was added.  The 256 jump limit is discutable, but this is
only my humble suggestion of a temporary fix.

One might wonder, however, if this type of bug could also be present in
other software that also extracts domain names from UDP packets containing
DNS queries or reply.  I would suggest anyone running software that inspects
contents of DNS traffic to test themselves against this.


Cheers,

Hugo Breton
bretonh@pgci.ca
