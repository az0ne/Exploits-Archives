-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Wordpress Security audit
2-click-socialmedia-buttons

1. Cross-site scripting (reflected)

Summary

Severity:   	High
Confidence:   	Certain
Host:   	http://127.0.0.1
Path:   	/wp-content/plugins/2-click-socialmedia-buttons/libs/xing.php

Issue detail

The value of the xing-url request parameter is copied into the value
of an HTML tag attribute which is encapsulated in double quotation marks.
The payload 6aab0"><script>alert(1)</script>dcc8a4b02da was submitted
in the xing-url parameter.
This input was echoed unmodified in the application's response.

This proof-of-concept attack demonstrates that it is possible to
inject arbitrary JavaScript into the application's response.
Issue background Reflected cross-site scripting vulnerabilities arise
when data is copied from a request and echoed into the application's
immediate response in an unsafe way. An attacker can use the
vulnerability to construct a request which, if issued by another
application user, will cause JavaScript code supplied by the attacker
to execute within the user's browser in the context of that user's
session with the application.

The attacker-supplied code can perform a wide variety of actions, such
as stealing the victim's session token or login credentials,
performing arbitrary actions on the victim's behalf, and logging their
keystrokes.

Users can be induced to issue the attacker's crafted request in
various ways. For example, the attacker can send a victim a link
containing a malicious URL in an email or instant message. They can
submit the link to popular web sites that allow content authoring, for
example in blog comments. And they can create an innocuous looking web
site which causes anyone viewing it to make arbitrary cross-domain
requests to the vulnerable application (using either the GET or the
POST method).

The security impact of cross-site scripting vulnerabilities is
dependent upon the nature of the vulnerable application, the kinds of
data and functionality which it contains, and the other applications
which belong to the same domain and organisation. If the application
is used only to display non-sensitive public content, with no
authentication or access control functionality, then a cross-site
scripting flaw may be considered low risk. However, if the same
application resides on a domain which can access cookies for other
more security-critical applications, then the vulnerability could be
used to attack those other applications, and so may be considered high
risk. Similarly, if the organisation which owns the application is a
likely target for phishing attacks, then the vulnerability could be
leveraged to lend credibility to such attacks, by injecting Trojan
functionality into the vulnerable application, and exploiting users'
trust in the organisation in order to capture credentials for other
applications which it owns. In many kinds of application, such as
those providing online banking functionality, cross-site scripting
should always be considered high risk.
Issue remediation In most situations where user-controllable data is
copied into application responses, cross-site scripting attacks can be
prevented using two layers of defences:

Input should be validated as strictly as possible on arrival, given
the kind of content which it is expected to contain. For example,
personal names should consist of alphabetical and a small range of
typographical characters, and be relatively short; a year of birth
should consist of exactly four numerals; email addresses should match
a well-defined regular expression. Input which fails the validation
should be rejected, not sanitised.
User input should be HTML-encoded at any point where it is copied into
application responses. All HTML metacharacters, including < > " ' and
=, should be replaced with the corresponding HTML entities (&lt; &gt;
etc).

In cases where the application's functionality allows users to author
content using a restricted subset of HTML tags and attributes (for
example, blog comments which allow limited formatting and linking), it
is necessary to parse the supplied HTML to validate that it does not
use any dangerous syntax; this is a non-trivial task.

Request
GET
/wp-content/plugins/2-click-socialmedia-buttons/libs/xing.php?xing-url=16aab0"><script>alert(1)</script>dcc8a4b02da
HTTP/1.1
Host: 127.0.0.1
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:11.0)
Gecko/20100101 Firefox/11.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip, deflate
Proxy-Connection: keep-alive
Cookie: wp-settings-1=widgets_access%3Doff%26uploader%3D1;
wp-settings-time-1=1333368822

Response
HTTP/1.1 200 OK
Date: Mon, 02 Apr 2012 19:49:50 GMT
Server: Apache/2.2.20 (Ubuntu)
X-Powered-By: PHP/5.3.6-13ubuntu3.6
Vary: Accept-Encoding
Content-Length: 477
Content-Type: text/html


   <!DOCTYPE html>
<html>
<head>
<style type="text/css">
html,
body {
margin:0;
padding:0;
width:auto;
/*overflow:hidden;*/

...[SNIP]...
<script type="XING/Share" data-counter="right" data-lang="de"
data-url="16aab0"><script>alert(1)</script>dcc8a4b02da">
...[SNIP]...

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.11 (GNU/Linux)

iQIcBAEBAgAGBQJPrDgzAAoJEJPBwXYLR9Vtb9IQAL8PvmVCaSujlEwDLoiaKWM3
huSZX2MM+V2hUWxg6vsoyaCQh81DMt+Ckq5fH4BjiOsCA0qvjMI4ocM6/NeKwDw0
7WZVuxXPEtsqFC2X+sUeIwUSHR37xm1lw/q/6+JLsKy0+3OmQ2ycf2Qks/81/x8i
OrjU7cOHvYiPGzDC8ZCWHu/SF67N/OvQghV2YuVy3BE0ctWFapw2gY0CH6tcG6Bn
fGXnLYkCZyPdWCWBziM3E3cjlDgrM5LhLADosQj7nSIRKUxf+dqgfPadPeSF7eH/
xq+yARgAnHiHUYH2QPARfz4E4rDZas9+yo0lHorzDz5fgjAH7nsW47a/v6dN27pC
RT331Jiflcm3rLkH/kICy3c/T072IX8pfZ17dzdtYrnwO/NYxUJMUXn8VSwfZr7g
cSxFQZABGdsmu0DCOzCVNfTfsJYhXtI0zZ4EZkYf19oUFjn5O2WQWSItiD66wNpx
RXOeXPYExZIQTs1HT3/b+CR4oLW5cR5z/ihHBbQKMfKVsmRtwZFwY9PkrJt6WiV0
4CzRGLKpBA0lJCWJQiMiEM9Iie2iYVQjIByIko7xr9BOTf/uJ9q3WZ45888eP4Sl
2N2iFDcGBjKGhz56RQSmY7lT6n1Otd4FMahZgya5C5DUcsmxbxFybOmrj1FBh2IA
lEpt3Fdg3UCD3ASN+7Gc
=Vi26
-----END PGP SIGNATURE-----
